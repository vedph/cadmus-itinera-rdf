# Work Mappings

- [JSON mappings](work-mappings.json)

These mappings refer to work items. A work item is an item representing a literary work. The work's EID is provided in the item's `MetadataPart`.

## Item

As each work item has a metadata part, we map its `eid` metadatum as the work's ID. To make it a globally unique URI, the mapping builds it as follows:

1. prefix `itn:works/`
2. work item's GUID
3. `/` + work EID

where (2) grants its uniqueness, and (1+3) its friendliness.

Also, this node is the subject of a triple telling that the work is a CIDOC-CRM E90 symbolic object.

## Events

Events related to the work are listed in the work item's events part. The event type is provided by a thesaurus entry, and so are the relation types for that event with reference to directly related entities.

In general:

- each event corresponds to an entity node, whose URI is `itn:events/PART-GUID/EID`.
- each event has at least 3 triples where the event is the subject:
  - event is an E7 activity.
  - event P2 has type + the event's type as derived from the thesaurus entry. The entity for this entry has URI `itn:event-types/ID`.
  - event P16 used specific object + the work entity. This connects the event with its work.

Also, a number of children mappings are provided for each event mapping. The following mappings are always the same, and thus shared among all the event mappings:

- description for the event's optional description.
- note for the event's optional note.
- chronotopes for the event's optional date(s)/time(s).

Also, there is an additional child mapping for each type of relation in the list of the event's related entities. For instance, the _text sent_ event has these possible relations:

- sender
- recipient
- has participant

Each of these mappings outputs 1 node for the related entity, and at least 1 triple connecting the event with the related entity.

As a sample, this child mapping:

```json
{
  "name": "text sent event/related/has_participant",
  "source": "relatedEntities[?relation=='text:send:recipient']",
  "output": {
    "nodes": {
      "recipient": "{@id.target.gid}"
    },
    "triples": ["{?event} crm:P11_has_participant {?recipient}"]
  }
}
```

matches the relation type `text:send:recipient`, and outputs:

- a node for the recipient, whose URI is equal to the link's target GID.
- a triple telling that event P11 has participant recipient.

### Editorial Conventions

The entities involved in the events, and more generally in other parts, require a preliminary decision about editorial conventions. Most Cadmus models linking their data to entities outside the model itself do it via a link model which can be used both for external and internal links.

**External links** are just globally unique identifiers drawn from some LOD ontology (as URI, e.g. DBPedia) or any other external resources. For instance, <http://dbpedia.org/resource/Petrarch> could be the URI used for Petrarch. Anyway, the GID does not need to be a URI or any other globally unique identifier; it must be unique at least in the context of the database. In the end, an external link is just a user-defined string, with a corresponding label.

**Internal links** are links cross referencing two entities found in the Cadmus database, via entity IDs (EIDs). An EID can be assigned to an item as a whole (via its `MetadataPart`, by a convention assuming that the metadatum named eid refers to the item including that part), or to any entity defined in a part's model. The provided UI (from bricks) allows user to lookup these EIDs by just typing any of their characters, and eventually filter them by item and part.

In both cases, the [link model](https://github.com/vedph/cadmus-bricks-shell/blob/master/projects/myrmidon/cadmus-refs-asserted-ids/README.md#asserted-composite-id) is the same, and includes a GID, i.e. a globally unique ID, plus some metadata. For external links, the GID is just the ID entered by users. For internal links, the GID usually is generated by a convention which ensures both a human-readable and globally unique ID, by merging a GUID (from a part or item) with the human-friendly EID. For instance, a GID like:

```txt
P3e04b8d1-7b55-4de7-b2b8-3097017c7c82/petrarch
```

can be dissected as:

- a `P` prefix telling us that the GUID belongs to a part (for an item we would have `I`).
- the part's (or item's) GUID.
- the EID (here `petrarch`) prefixed by `/`.

>The UI also allows users to customize the GID, if your Cadmus project is configured for this (via a thesaurus).

As for **mapping**, the typical scenarios are:

(A) _copied external links_: true URIs or other global identifiers can be copied without changes. In this case, you are using a globally unique ID as your external link, like <http://dbpedia.org/resource/Petrarch>. So, the mapping will just assume this as the URI of the projected node.

(B) _mapped external links_: identifiers which are unique only within the editor database can be given a more graph-like ID, while still keeping them inside the project's namespace. For instance, say you want to use simple toponyms as place identifiers. Of course, you stick to some convention ensuring that all the place names you use are connected to a single place entity, disambiguating where necessary; and that all the place names are always spelled the same way. Apart from these obvious editorial conventions, you are then free to just type place names in the language and form which is considered standard for your project. For instance, we could just enter place names like `Roma`, `Arezzo`, etc. Then, a mapping rule might just add some prefix common to all place names, e.g. `itn:places/` for the _Itinera_ project, thus generating URIs like `itn:places/Roma`. Later, you might eventually alias these URIs by matching them with one or more gazetteer services, or a predefined list of some sort. This way, you will provide them with additional metadata like geographical location etc., while still keeping data entry as friendly as possible.

(C) _mapped internal links_: internal links will be mapped in some way to generate URIs from them. For instance, say you used a link to refer to Petrarch. In this case, the link model will include not only a preset internal GID as explained above; but also all the metadata referred to the pin-based lookup operation which led to target Petrarch: item ID, part ID, pin name, pin value, etc. So, your mapping can use such metadata to build a URI like e.g. `itn:persons/3e04b8d1-7b55-4de7-b2b8-3097017c7c82/petrarch`, which is built from:

1. a prefix common to all the persons in our database (`itn:persons/`);
2. the GUID of the item corresponding to the Petrarch entity; this GUID ensures that the resulting URI is globally unique;
3. the EID of the item corresponding to the Petrarch entity (`petrarch`), which makes the URI human-friendly.

So, instead of having a mapping like this, which just copies the GID as for case (A) above (`"recipient": "{@id.target.gid}"`):

```json
{
  "name": "text sent event/related/has_participant",
  "source": "relatedEntities[?relation=='text:send:recipient']",
  "output": {
    "nodes": {
      "recipient": "{@id.target.gid}"
    },
    "triples": ["{?event} crm:P11_has_participant {?recipient}"]
  }
}
```

we would have:

```json
{
  "name": "text sent event/related/has_participant",
  "source": "relatedEntities[?relation=='text:send:recipient']",
  "output": {
    "nodes": {
      "recipient": "itn:persons/{@id.target.itemId}/{@id.target.value}"
    },
    "triples": ["{?event} crm:P11_has_participant {?recipient}"]
  }
}
```

where the recipient URI is built exactly as explained in the above sample: a prefix, the item's GUID, and the item's EID (which corresponds to the name of the pin, as the item's EID comes from the `eid` metadatum of the metadata part for that item): `"recipient": "itn:persons/{@id.target.itemId}/{@id.target.value}"`.

Of course, this means that you might have different mappings when mixing both external and internal identifiers in the same category of links. As an internal link can be easily distinguished from an external one by the presence of pin-only properties like the pin's `name`, you can have two mappings for the same related entity, one with an internal link and another with an external link; and generate the corresponding URI in different ways.
