# Links

Entities involved in [events](events.md), and more generally in other parts, require a preliminary decision about editorial conventions. Most Cadmus models linking their data to entities outside the model itself do it via a link model which can be used both for external and internal links.

**External links** are just globally unique identifiers drawn from some LOD ontology (as URI, e.g. DBPedia) or any other external resources. For instance, <http://dbpedia.org/resource/Petrarch> could be the URI used for Petrarch. Anyway, the GID does not need to be a URI or any other globally unique identifier; it must be unique at least in the context of the database. In the end, an external link is just a user-defined string, with a corresponding label.

**Internal links** are links cross referencing two entities found in the Cadmus database, via entity IDs (EIDs). An EID can be assigned to an item as a whole (via its `MetadataPart`, by a convention assuming that the metadatum named eid refers to the item including that part), or to any entity defined in a part's model. The provided UI (from bricks) allows user to lookup these EIDs by just typing any of their characters, and eventually filter them by item and part.

In both cases, the [link model](https://github.com/vedph/cadmus-bricks-shell/blob/master/projects/myrmidon/cadmus-refs-asserted-ids/README.md#asserted-composite-id) is the same, and includes a GID, i.e. a globally unique ID, plus some metadata. For external links, the GID is just the ID entered by users. For internal links, the GID usually is generated by a convention which ensures both a human-readable and globally unique ID, by merging a GUID (from a part or item) with the human-friendly EID. For instance, a GID like:

```txt
P3e04b8d1-7b55-4de7-b2b8-3097017c7c82/petrarch
```

can be dissected as:

- a `P` prefix telling us that the GUID belongs to a part (for an item we would have `I`).
- the part's (or item's) GUID.
- the EID (here `petrarch`) prefixed by `/`.

>The UI also allows users to customize the GID, if your Cadmus project is configured for this (via a thesaurus).

As for **mapping**, the typical scenarios are:

(A) _copied external links_: true URIs or other global identifiers can be copied without changes. In this case, you are using a globally unique ID as your external link, like <http://dbpedia.org/resource/Petrarch>. So, the mapping will just assume this as the URI of the projected node.

(B) _mapped external links_: identifiers which are unique only within the editor database can be given a more graph-like ID, while still keeping them inside the project's namespace. For instance, say you want to use simple toponyms as place identifiers. Of course, you stick to some convention ensuring that all the place names you use are connected to a single place entity, disambiguating where necessary; and that all the place names are always spelled the same way. Apart from these obvious editorial conventions, you are then free to just type place names in the language and form which is considered standard for your project. For instance, we could just enter place names like `Roma`, `Arezzo`, etc. Then, a mapping rule might just add some prefix common to all place names, e.g. `itn:places/` for the _Itinera_ project, thus generating URIs like `itn:places/Roma`. Later, you might eventually alias these URIs by matching them with one or more gazetteer services, or a predefined list of some sort. This way, you will provide them with additional metadata like geographical location etc., while still keeping data entry as friendly as possible.

(C) _mapped internal links_: internal links will be mapped in some way to generate URIs from them. For instance, say you used a link to refer to Petrarch. In this case, the link model will include not only a preset internal GID as explained above; but also all the metadata referred to the pin-based lookup operation which led to target Petrarch: item ID, part ID, pin name, pin value, etc. So, your mapping can use such metadata to build a URI like e.g. `itn:persons/3e04b8d1-7b55-4de7-b2b8-3097017c7c82/petrarch`, which is built from:

1. a prefix common to all the persons in our database (`itn:persons/`);
2. the GUID of the item corresponding to the Petrarch entity; this GUID ensures that the resulting URI is globally unique;
3. the EID of the item corresponding to the Petrarch entity (`petrarch`), which makes the URI human-friendly.

So, instead of having a mapping like this, which just copies the GID as for case (A) above (`"recipient": "{@id.target.gid}"`):

```json
{
  "name": "text sent event/related/has_participant",
  "source": "relatedEntities[?relation=='text:send:recipient']",
  "output": {
    "nodes": {
      "recipient": "{@id.target.gid}"
    },
    "triples": ["{?event} crm:P11_has_participant {?recipient}"]
  }
}
```

we would have:

```json
{
  "name": "text sent event/related/has_participant",
  "source": "relatedEntities[?relation=='text:send:recipient']",
  "output": {
    "nodes": {
      "recipient": "itn:persons/{@id.target.itemId}/{@id.target.value}"
    },
    "triples": ["{?event} crm:P11_has_participant {?recipient}"]
  }
}
```

where the recipient URI is built exactly as explained in the above sample: a prefix, the item's GUID, and the item's EID (which corresponds to the name of the pin, as the item's EID comes from the `eid` metadatum of the metadata part for that item): `"recipient": "itn:persons/{@id.target.itemId}/{@id.target.value}"`.

Of course, this means that you might have different mappings when mixing both external and internal identifiers in the same category of links. As an internal link can be easily distinguished from an external one by the presence of pin-only properties like the pin's `name`, you can have two mappings for the same related entity, one with an internal link and another with an external link; and generate the corresponding URI in different ways.

As a sample, consider this event mapping with a single related entity type (`text:send:recipient`) for brevity:

```json
{
  "name": "text sent event",
  "sourceType": 2,
  "facetFilter": "work",
  "partTypeFilter": "it.vedph.historical-events",
  "description": "Map text sent event",
  "source": "events[?type=='text.send']",
  "sid": "{$part-id}/{@[0].eid}",
  "output": {
    "metadata": {
      "id": "{$part-id}/{@eid}",
      "work": "itn:works/{$metadata-pid}/{$item-eid}"
    },
    "nodes": {
      "event": "itn:events/{$id} itn:events/{@eid}"
    },
    "triples": [
      "{?event} a crm:E7_Activity",
      "{?event} crm:P2_has_type itn:event-types/text.send",
      "{?event} crm:P16_used_specific_object {$work}"
    ]
  },
  "children": [
    {
      "name": "event_description"
    },
    {
      "name": "event_note"
    },
    {
      "name": "event_chronotopes"
    },
    {
      "name": "text sent event/related/has_participant",
      "source": "relatedEntities[?relation=='text:send:recipient' && !id.target.name]",
      "output": {
        "nodes": {
          "recipient": "{@id.target.gid}"
        },
        "triples": ["{?event} crm:P11_has_participant {?recipient}"]
      }
    },
    {
      "name": "text sent event/related/has_participant",
      "source": "relatedEntities[?relation=='text:send:recipient' && id.target.name]",
      "output": {
        "nodes": {
          "recipient": "itn:persons/{@id.target.partId}/{@id.target.value}"
        },
        "triples": ["{?event} crm:P11_has_participant {?recipient}"]
      }
    }
  ]
}
```

In these mappings, you should notice that:

- the work URI is built from prefix `itn:works/` + the GUID of the metadata part for the work item + `/` + item's EID.
- there are 2 children mappings for the recipient entity: one matches the recipient ID represented by an external link (`!id.target.name` = there is no target name in the ID), another matches the recipient ID represented by an internal link (`id.target.name` = there is a target name in the ID, which means that this is a pin-based link, i.e. internal).

>As noted above, the target URI is built with the _part_ ID rather than with the _item_ ID. We could also use `itemId`, but only if we are sure that all the related entities correspond to items. If instead an entity is defined only in a part, it would make no sense to target its container item; sure, the resulting URI would be globally unique, but in practice we would lose the direct connection between the link and its target part. So, the general rule is just sticking to the most granular GUID, i.e. use part ID unless not present.

## Itinera Conventions

In _Itinera_, there are 3 types of links:

- **internal**: an internal link between two entities in the database. This is marked by the presence of `id.target.name`.
- **external**: marked by the absence of `id.target.name`, divided in:
  - **global** link: a true external link, like a DBPedia URI. In Itinera this is a marked case, and is distinguished by local links by a `@` prefix before the ID.
  - **local** link: a link which does not refer to a database entity, but is local to the database context, e.g. `scipione_barbato`. This is a conventional identifier which makes sense and is unique only within the context of the Itinera project, though not referred to an entity existing in the database.

So, the match conditions are:

- internal: `relatedEntities[?relation=='THESAURUS_ID' && id.target.name`
- external, global: `relatedEntities[?relation=='THESAURUS_ID' && !(id.target.name) && starts_with(id.target.gid, '@')]`. In this case, we will have to remove the `@` prefix when mapping, e.g. with `slice(target.gid, 1)`.
- external, local: `relatedEntities[?relation=='THESAURUS_ID' && !(id.target.name) && !(starts_with(id.target.gid, '@'))]`
